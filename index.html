<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Α Macronizer for Ancient Greek 0.1</title>
    <style>
        @font-face {
            font-family: 'New Athena Unicode';
            src: url('fonts/new-athena-unicode.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        body {
            font-family: sans-serif; /* Use default font */
            margin: 0;
            padding: 20px;
        }

        #searchBox {
            font-family: 'New Athena Unicode', sans-serif;
        }

        .search-input {
            font-family: 'New Athena Unicode', sans-serif;
        }

        /* Style for the tan info box */
        .info-box {
            background-color: #d2b48c; /* Tan background color */
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
        }

        .info-box a {
            color: #0066cc;
            text-decoration: none;
        }

        .info-box a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Macron Search</h1>
    <input type="text" id="searchBox" placeholder="Enter name">
    <button onclick="searchTSV()">Search</button>
    <p id="result"></p>

    <div class="info-box">
        <p>The macronizer is limited to tragic vocabulary, i.e. to around 41,000 word forms appearing in the extant works of Aeschylus, Sophocles, and Euripides. Begun as a master project by Albin Thörn Cleland, it is primarily based on a collation of the vowel length data of LSJ and Wiktionary. Around three thousand entries have been disambiguated because they contain dichrona in open syllables included in the scanned corpus on David Chamberlain's marvellous <a href="https://hypotactic.com" target="_blank">hypotactic.com</a>. Many endings have been macronized algorithmically based on conjugation and declension tables. Each result has a source indication.</p>
        <p>To contact me or suggest features, see the GitHub repositories for the <a href="https://github.com/Urdatorn/greek-macronizer-site" target="_blank">site</a> and the <a href="https://github.com/Urdatorn/greek-macronizer" target="_blank">backend</a>.</p>
        <p>To learn more about how exactly I went about collecting the data, see my <a href="macronizer_thesis_prel.pdf" target="_blank">master thesis</a>.</p>
    </div>

    <script>
        // Greek alphabet regex
        const baseAlphabet = /[ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψω]/;

        // Function to get the base character after normalization
        function base(ch) {
            return ch.normalize('NFD')[0];
        }

        // Function to apply diacritical marks based on instructions
        function applyDiacritics(input, instructions) {
            const combiningMacron = '\u0304'; // Combining Macron
            const combiningBreve = '\u0306'; // Combining Breve

            // Split the instructions into pairs
            const instructionsArray = instructions.match(/[_^]\d+/g);
            if (!instructionsArray) return input; // No instructions

            // Filter Greek alphabet characters from the input
            let filteredInput = Array.from(input).filter(char => baseAlphabet.test(base(char)));

            // Apply diacritical marks based on the instructions
            for (const instruction of instructionsArray) {
                const type = instruction[0]; // '_' or '^'
                const index = parseInt(instruction.slice(1), 10) - 1; // Convert to 0-based index

                if (index >= 0 && index < filteredInput.length) {
                    if (type === '_') {
                        // Combine with Macron
                        filteredInput[index] += combiningMacron;
                    } else if (type === '^') {
                        // Combine with Breve
                        filteredInput[index] += combiningBreve;
                    }
                }
            }

            return filteredInput.join('');
        }

        async function searchTSV() {
            const searchValue = document.getElementById('searchBox').value.trim();
            const response = await fetch('macrons_alg4_barytone.tsv');
            const tsvData = await response.text();
            
            const lines = tsvData.split('\n').slice(1); // Skip the header
            let result = "Not found";

            for (const line of lines) {
                const columns = line.split('\t');
                const name = columns[0].trim().toLowerCase();
                const resultCol = columns[3];
                let sourceCol = columns[4];
                
                if (name === searchValue.trim().toLowerCase()) {
                    if (sourceCol.trim().toLowerCase() === 'breve_ultima') {
                        sourceCol = 'Morphological tables for breve on the ultima';
                    }
                    // Apply diacritics based on the fourth column data
                    const modifiedInput = applyDiacritics(searchValue, resultCol);
                    result = `<span class="search-input">${modifiedInput}</span>: ${resultCol} (Source: ${sourceCol})`;
                    break;
                }
            }

            document.getElementById('result').innerHTML = result;
        }
    </script>
</body>
</html>
